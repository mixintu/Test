# coding=utf-8# @author   ：迷心兔# time      ：2019/11/10from django.forms import ModelFormfrom django.test import TestCasefrom django.urls import resolve, reversefrom django.utils import timezonefrom ..models import Postfrom ..views import post_editfrom django.contrib.auth.models import User# 测试编辑页面class EditTests(TestCase):    def setUp(self):        user = User.objects.create_user(username = "mi", password = "123456")        self.post = Post.objects.create(            author = user,            title = "test title",            text = "test text",            created_date = timezone.now( ),            published_date = timezone.now( ),        )        self.post_edit_url = reverse('post_edit', kwargs = {'pk': self.post.pk})# 需要登录后更新查看测试class LoginRequiredPostEditViewTests(EditTests):    # 测试失败响应码    def test_view_post_edit_not_found_status_code(self):        self.response = self.client.get(self.post_edit_url)        self.assertEquals(self.response.status_code, 302)    # 测试重定向操作    def test_redirection(self):        login_url = reverse('login')        response = self.client.get(self.post_edit_url)        self.assertRedirects(response, '{login_url}?next={url}'.format(login_url = login_url, url = self.post_edit_url))# 未经授权的更新后查看测试class UnauthorizedPostEditViewTests(EditTests):    def setUp(self):        super( ).setUp( )        username = 'who'        password = '654321'        User.objects.create_user(username = username, password = password)        self.client.login(username = username, password = password)        self.response = self.client.get(self.post_edit_url)    # 测试不是作者也能显示编辑页面，提示错误信息    def test_view_post_edit_success_status_code(self):        self.assertEquals(self.response.status_code, 200)    # 测试不是作者页面中是否包含某些链接    def test_view_post_edit_contains_link_to_topics_page(self):        post_list_url = reverse('post_list')        self.assertContains(self.response, 'href="{0}"'.format(post_list_url))class AuthorPostEditTests(EditTests):    def setUp(self):        super( ).setUp( )        self.client.login(username = "mi", password = "123456")        self.response = self.client.get(self.post_edit_url)    # 测试成功响应码    def test_view_post_edit_success_status_code(self):        self.assertEquals(self.response.status_code, 200)    # 测试链接能正常显示    def test_url_edit_resolves_view(self):        view = resolve('/blog/post/1/edit/')        self.assertEquals(view.func, post_edit)    # 测试页面中是否包含某些链接    def test_view_post_edit_contains_navigation_links(self):        logout_url = reverse('logout')        url = reverse('post_new')        response = self.client.get(url)        self.assertContains(response, 'href="{0}"'.format(logout_url))    # 测试表单是否存在    def test_contains_form(self):        form = self.response.context.get('form')        self.assertIsInstance(form, ModelForm)    # 测试表单是否设置跨站防护    def test_csrf(self):        self.assertContains(self.response, 'csrfmiddlewaretoken')    # 测试表单组件是否存在    def test_form_inputs(self):        self.assertContains(self.response, '<input', 2)        self.assertContains(self.response, '<textarea', 1)    # 测试表单提交后的重定向链接    def test_redirection(self):        response = self.client.post(            self.post_edit_url,            {                "title": "test new title",                "text" : "test new text",            }        )        post_detail_url = reverse('post_detail', kwargs = {'pk': int(self.post.pk)})        self.assertRedirects(response, post_detail_url)